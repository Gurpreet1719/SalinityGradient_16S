---
title: "Phyloseq PreProcessing"
author: "Gurpreet Kaur"
date: "`r Sys.Date()`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      fig.align = "center",
                      fig.path = "../figures/02_PreProcessing/") #send any figure output to this folder
```


# Load our libraries
```{r load-libraries}
#library(devtools)
#BiocManager::install("phyloseq")
#library(phyloseq)
#library(tidyverse)

pacman::p_load(devtools, phyloseq, tidyverse, dada2, install = FALSE)
```
#Goals

Here, we will process the data into a phyloseq object.

-ASV table
-Taxonomy table
-Track reads (metadata)

Then, we will remove the following:

1.Remove chloroplast
2.Remove mitochondria
3. Remove samples without enough reads
4. Remove samples without enough reads.
5. Evaluate accuracy by looking at the mock community

Finally, write a data file of phyloseq output, which will be stored in 'data/02_PreProecessing/raw_preprocessed_phyloseq.RData'.

#Load data

##Load ASV table
```{r load-ASV-table}
#First, load ASV table
load("data/01_DADA2/ASV_counts.RData")

#inspect asv_tab
head(asv_tab)[,1:5]

#Fix the names
sample_names <- colnames(asv_tab)
samples_fixed <- sapply(strsplit(basename(sample_names), "_"), `[`,1) 
head(samples_fixed)

#rewrite the ASV count file to fix names
colnames(asv_tab) <- samples_fixed
str(asv_tab)


```


##Taxonomy table
```{r load-tax-table}
tax_df <- read.table("data/01_DADA2/ASV_taxonomy.tsv", sep = "\t", skip = 1)
head(tax_df)

#fix column names
colnames(tax_df) <- c("asv_names", "Kingdom", "Phylum", "Class", "Order",  "Family", "Genus", "Species", "ASV", "ASVseq")

head(tax_df)

#Taxonomy table matrix
tax_mat <-
tax_df %>%
  tibble::column_to_rownames(., var = "asv_names") %>%
  as.matrix()
```

##Track reads data
```{r load-track-reads}
load("data/01_DADA2/track_read_counts.RData")

#Take a look at the data
head(track_counts_df)
dim(track_counts_df)

#Load in the metadata

metadata_df <- read.csv("data/metadata.csv")
dim(metadata_df)
colnames(metadata_df)

#Merge metadata_df with track_reads_df
head(metadata_df)
head(track_counts_df)

metadata_tracks_reads_df <- 
  metadata_df %>% 
  left_join(., track_counts_df, by = "names") %>%
  dplyr::select(-X) 

#Intuition check
head(metadata_tracks_reads_df)

#Update row.names to be sample names
##Before
row.names(metadata_tracks_reads_df)
#Rewrite
row.names(metadata_tracks_reads_df) <- metadata_tracks_reads_df$names
#Check afterwards
row.names(metadata_tracks_reads_df)

head(metadata_tracks_reads_df)
```

#Handoff to phyloseq
```{r phyloseq-handoff}
#double check it is all good
dim(asv_tab)
dim(tax_mat)

#Intuition check
stopifnot(row.names(asv_tab) == row.names(tax_mat))

#construct the phyloseq object
raw_physeq <- raw_phyloseq <- phyloseq(otu_table(asv_tab, taxa_are_rows = TRUE), 
                         sample_data(metadata_tracks_reads_df),
                         tax_table(tax_mat))
raw_physeq

#save the raw_phyloseq object
save(raw_physeq, file = "data/02_PreProcessing/raw_physeq.RData")
```


#Clean up the data

Remove:
1. Chloroplasts
2. Mitochondria

```{r rm-mitos-chloros}
#Remind myself of tax table
View(tax_mat)

#Make a new physeq without mitochondria or chloroplasts
noChloros_physeq <- 
  raw_phyloseq %>%
  #rm chloroplasts
  subset_taxa(Order != "Chloroplast" | is.na(Order))
  
#how many taxa were chloroplasts?
num_chloro_ASVs <- ntaxa(raw_physeq) - ntaxa(noChloros_physeq)
num_chloro_ASVs

#Intuition check
#noChloros_physeq %>%
  #tax_table() %>%
  #data.frame() %>%
  #View()
  
  
  #Remove mitochondria
  noChlorosMitos_physeq <- 
    noChloros_physeq %>%
    subset_taxa(Family != "Mitochondria" | is.na(Family))
  
  
#How many mitochondrial ASVs?
  num_mito_ASVs <- ntaxa(noChloros_physeq) - ntaxa(noChlorosMitos_physeq)
  num_mito_ASVs 
  
noChlorosMitos_physeq

#How many total ASVs were removed from chloros and mito?
ntaxa(raw_physeq) - ntaxa(noChlorosMitos_physeq)
#proportion of ASVs kept?
ntaxa(noChlorosMitos_physeq)/ntaxa(raw_physeq)
```


#Evaluate and remove the control samples

Take a look at the negative controls and then make decision about whether or not to remove the ASVs that we found in our controls

1. Negative controls
2. ASVs found within the negtive controls and their distribution in the samples.
3. Evaluate the mock community

##Negative controls
```{r neg-controls}
#create a vector of samples that were negative controls
control_samples <- c("WaterControl", "022um-Control",
                     "3um-Control", "DNA-Ext-Control")

#Make a new phyloseq object of only the control samples
control_physeq <- 
  noChlorosMitos_physeq %>%
  subset_samples(., names %in% control_samples) %>%
  #force remove ASVs with 0 counts
  prune_taxa(taxa_sums(.) > 0, .)



#vector of control asvs

control_ASVs <- 
  control_physeq %>%
  tax_table() %>%
  data.frame() %>%
  dplyr::select(ASV) %>%
  as.vector()
  
#visulize the raw abundance values of control ASVs
control_physeq %>%
  plot_bar(., "ASV", fill = "ASV")

###Check the control ASVs in the samples
#Make a new phyloseq object of only the control samples and all samples
control_ASV_physeq <-
  noChlorosMitos_physeq %>%
  subset_taxa(., ASV %in% control_ASVs$ASV)

#Inspect
control_ASV_physeq


#Let's take a look at the abundances
control_ASV_physeq %>%
  plot_bar(., "ASV", fill = "ASV", facet_grid = Sample_or_Control~.)

#Would only like to keep ASV 18 and 56
control_ASVs_toREMOVE <- dplyr::setdiff(control_ASVs$ASV, c("ASV_18", "ASV_56"))
#double check
length(control_ASVs_toREMOVE)

#make new phyloseq object
noControls_ChlorosMitos_phyloseq <-
  noChlorosMitos_physeq %>%
  #Actually remove control ASVs except 18 and 56
  subset_taxa(., !(ASV %in% control_ASVs_toREMOVE)) %>%
 #Remove control samples
subset_samples(., !(names %in% control_samples))
```


#Evaluate accuracy in the mock community
-make a mock phyloseq object
-load in the standard fasta sequences of the mock community
-test for differences between the two

```{r}
#make mock phyloseq object
mock_physeq <-
  noControls_ChlorosMitos_phyloseq %>%
  subset_samples(., names == "MockZymoPos") %>%
  prune_taxa(taxa_sums(.) > 0, .)

#Inspect it
mock_physeq
tax_table(mock_physeq)

#Writes us a message summarizing this
cat("DADA2 inferred", ntaxa(mock_physeq), "ASVs present in the mock community")

#####Load in the mock reference sequence from zymo
mock_ref <- getSequences("data/02_PreProcessing/mock_amplicons.fasta")
names(mock_ref)

#Pull out seqs from sequenced mock communities
mock_seqs <- 
  mock_physeq %>%
  tax_table() %>%
  data.frame() %>%
  dplyr::select(ASV, ASVseq)

#Inspect
head(mock_seqs)

#Which ASVs match the reference?
matched_asvs <-
  mock_seqs %>%
  rowwise() %>%
  #check each ASV if they match is true otherwise false
  mutate(Match = any(grepl(ASVseq, mock_ref))) %>%
  pull(ASV)
  
cat(length(matched_asvs), "ASVs were exact matches to the expected references")

#How many sequences were there in mock?
mock_SeqDepth <-
  mock_physeq %>%
  otu_table() %>%
  data.frame() %>%
  colSums()
  
#evaluate which ones donot match
#What's their abundances?
#This help provide error rate


#Who is in the sequenced mock community?
mock_physeq %>%
  tax_table() %>%
  data.frame () %>%
  dplyr::select(Genus, Species)
names(mock_seqs)
names(mock_ref)


#curious: what are the mock counts in the actual samples?
noControls_ChlorosMitos_phyloseq %>%
  subset_taxa(., ASV %in% matched_asvs) %>%
  otu_table() %>%
  t()

```


What can we conclude about the mock community?
That all 8 asvs in the mock community match.

```{r-rm-mock-asvs}
noControlsMock_ChlorosMitos_phyloseq <-
noControls_ChlorosMitos_phyloseq %>%
  #remove the mock community
  subset_samples(., names != "MockZymoPos") %>%
  #remove the ASVs from the mock
  subset_taxa(., !(ASV %in% matched_asvs))

noControlsMock_ChlorosMitos_phyloseq 


#Intuition check
num_ASVs_mock <- ntaxa(noControls_ChlorosMitos_phyloseq) - ntaxa(noControlsMock_ChlorosMitos_phyloseq)

#check
stopifnot(num_ASVs_mock == 8)
```

#Evaluate the sequencind depth
```{r}
#the current data object
noControlsMock_ChlorosMitos_phyloseq

#What is the library size/sequencing depth for eacg samples?
seqSums_df <-
noControlsMock_ChlorosMitos_phyloseq %>%
  otu_table() %>%
  #sum each sample column
  colSums() %>%
  data.frame() %>%
  rownames_to_column(var = "names") %>%
  left_join(., metadata_tracks_reads_df)


dim(seqSums_df)
head(seqSums_df)


#rename second column
colnames(seqSums_df)[2] <- "TotalSeqs"

#plot it!
seqSums_df %>%
  ggplot(aes(x=reorder(names, TotalSeqs), y = TotalSeqs, fill = station)) +
           geom_bar(stat = "identity")

#density plot
seqSums_df %>%
  ggplot(aes(TotalSeqs, fill = station)) +
  geom_density(alpha = 0.5)

```

#remove samples with few reads
```{r rm-samples}
#what is the min sequencing depth?
min(sample_sums(noControlsMock_ChlorosMitos_phyloseq))

 # Remove 20210615-MA-SCB2F
raw_preprocessed_physeq <- 
  noControlsMock_ChlorosMitos_phyloseq %>%
  subset_samples(., names != "20210615-MA-SCB2F")

#What's the new min seq depth?
min(sample_sums(raw_preprocessed_physeq))
```


# Save Preprocessed Phyloseq Object
```{r save-physeq}
save(raw_preprocessed_physeq,
     file = "data/02_PreProcessing/raw_preprocessed_physeq.RData")
```

#Session information
```{r}
#ensure reproducibility
devtools::session_info()
```

